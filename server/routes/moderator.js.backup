const express = require('express');
const router = express.Router();
const verifyToken = require('../middleware/verifyToken');
const { verifyModerator, verifySeriesModerator } = require('../middleware/verifyModerator');
const fs = require('fs').promises;
const path = require('path');
const { 
  getSeriesFolderName, 
  getSeriesDisplayName, 
  isValidSeriesId, 
  validateChapterData 
} = require('../utils/seriesHelper');

// ModeratÃ¶rÃ¼n yÃ¶nettiÄŸi serileri getir
router.get('/my-series', verifyToken, verifyModerator, async (req, res) => {
  try {
    const user = req.moderatorUser;
    
    if (user.isAdmin) {
      // Admin tÃ¼m serileri gÃ¶rebilir
      const dataPath = path.join(__dirname, '../../client/da    // Chapter details'i sÄ±rala
    series.chapterDetails.sort((a, b) => a.number - b.number);
    
    // ğŸš€ YENÄ° Ã–ZELLÄ°K: Seriyi en baÅŸa getir (Son YÃ¼klenenler iÃ§in)
    // GÃ¼ncellenen seriyi diziden Ã§Ä±kar ve en baÅŸa ekle
    const updatedSeries = manhwalar.splice(seriesIndex, 1)[0];
    manhwalar.unshift(updatedSeries);
    console.log(`ğŸ“Œ ${series.title} serisi listenin en baÅŸÄ±na taÅŸÄ±ndÄ± (Moderator v2)`);
    
    // Dosyaya kaydet
    await fs.writeFile(dataPath, JSON.stringify(manhwalar, null, 2));
    
    res.json({
      success: true,
      message: `BÃ¶lÃ¼m ${chapterNumber} baÅŸarÄ±yla eklendi`,lar.json');
      const data = await fs.readFile(dataPath, 'utf8');
      const manhwalar = JSON.parse(data);
      
      return res.json({
        userType: 'admin',
        series: manhwalar.map(series => ({
          id: series.seriesId,
          title: series.title || series.name,
          status: series.status,
          author: series.author,
          artist: series.artist,
          publisher: series.publisher,
          summary: series.summary,
          genres: series.genres,
          image: series.image,
          label: series.label,
          chapters: series.chapters || []
        }))
      });
    }
    
    if (user.isModerator) {
      // ModeratÃ¶r sadece atanmÄ±ÅŸ serileri gÃ¶rebilir
      const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
      const data = await fs.readFile(dataPath, 'utf8');
      const manhwalar = JSON.parse(data);
      
      const moderatorSeries = manhwalar.filter(series => 
        user.moderatorSeries.includes(series.seriesId)
      );
      
      return res.json({
        userType: 'moderator',
        assignedSeries: user.moderatorSeries,
        series: moderatorSeries.map(series => ({
          id: series.seriesId,
          title: series.title || series.name,
          status: series.status,
          author: series.author,
          artist: series.artist,
          publisher: series.publisher,
          summary: series.summary,
          genres: series.genres,
          image: series.image,
          label: series.label,
          chapters: series.chapters || []
        }))
      });
    }
    
    res.status(403).json({ error: 'Yetkisiz eriÅŸim' });
  } catch (error) {
    console.error('ModeratÃ¶r serileri getirme hatasÄ±:', error);
    res.status(500).json({ error: 'ModeratÃ¶r serileri getirilemedi' });
  }
});

// Belirli bir seri iÃ§in moderatÃ¶r yetkisi kontrolÃ¼
router.get('/check-series-permission/:seriesId', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId } = req.params;
    const user = req.moderatorUser;
    
    let hasPermission = false;
    
    if (user.isAdmin) {
      hasPermission = true;
    } else if (user.isModerator && user.moderatorSeries.includes(seriesId)) {
      hasPermission = true;
    }
    
    res.json({
      hasPermission,
      userType: user.isAdmin ? 'admin' : 'moderator',
      seriesId
    });
  } catch (error) {
    console.error('Seri yetki kontrolÃ¼ hatasÄ±:', error);
    res.status(500).json({ error: 'Yetki kontrolÃ¼ yapÄ±lamadÄ±' });
  }
});

// Belirli bir seriyi getir
router.get('/series/:seriesId', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId } = req.params;
    const user = req.moderatorUser;
    
    // Yetki kontrolÃ¼
    if (!user.isAdmin && (!user.isModerator || !user.moderatorSeries.includes(seriesId))) {
      return res.status(403).json({ error: 'Bu seri iÃ§in yetkiniz yok' });
    }
    
    const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
    const data = await fs.readFile(dataPath, 'utf8');
    const manhwalar = JSON.parse(data);
    
    const series = manhwalar.find(s => s.seriesId === seriesId);
    if (!series) {
      return res.status(404).json({ error: 'Seri bulunamadÄ±' });
    }
    
    res.json({
      id: series.seriesId,
      title: series.title || series.name,
      status: series.status,
      author: series.author,
      artist: series.artist,
      publisher: series.publisher,
      summary: series.summary,
      genres: series.genres,
      image: series.image,
      label: series.label,
      chapters: series.chapters || []
    });
  } catch (error) {
    console.error('Seri detaylarÄ± getirme hatasÄ±:', error);
    res.status(500).json({ error: 'Seri detaylarÄ± alÄ±namadÄ±' });
  }
});

// ModeratÃ¶r profili
router.get('/profile', verifyToken, verifyModerator, async (req, res) => {
  try {
    const user = req.moderatorUser;
    
    res.json({
      id: user._id,
      username: user.username,
      email: user.email,
      isAdmin: user.isAdmin,
      isModerator: user.isModerator,
      moderatorSeries: user.moderatorSeries || [],
      createdAt: user.createdAt
    });
  } catch (error) {
    console.error('ModeratÃ¶r profil hatasÄ±:', error);
    res.status(500).json({ error: 'Profil bilgileri alÄ±namadÄ±' });
  }
});

// Seri bilgilerini gÃ¼ncelle
router.put('/update-series/:seriesId', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId } = req.params;
    const { title, status, author, artist, publisher, summary, genres, image, label } = req.body;
    const user = req.moderatorUser;
    
    // Seri ID validasyonu
    if (!isValidSeriesId(seriesId)) {
      return res.status(400).json({ 
        error: 'GeÃ§ersiz seri ID', 
        validIds: require('../utils/seriesHelper').getAllSeriesIds() 
      });
    }
    
    // Yetki kontrolÃ¼
    if (!user.isAdmin && (!user.isModerator || !user.moderatorSeries.includes(seriesId))) {
      return res.status(403).json({ error: 'Bu seri iÃ§in yetkiniz yok' });
    }
    
    const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
    const data = await fs.readFile(dataPath, 'utf8');
    const manhwalar = JSON.parse(data);
    
    const seriesIndex = manhwalar.findIndex(series => series.seriesId === seriesId);
    if (seriesIndex === -1) {
      return res.status(404).json({ error: 'Seri bulunamadÄ±' });
    }
    
    // Seri bilgilerini gÃ¼ncelle
    manhwalar[seriesIndex] = {
      ...manhwalar[seriesIndex],
      title: title || manhwalar[seriesIndex].title,
      status: status || manhwalar[seriesIndex].status,
      author: author || manhwalar[seriesIndex].author,
      artist: artist || manhwalar[seriesIndex].artist,
      publisher: publisher || manhwalar[seriesIndex].publisher,
      summary: summary || manhwalar[seriesIndex].summary,
      genres: genres || manhwalar[seriesIndex].genres,
      image: image || manhwalar[seriesIndex].image,
      lastUpdated: new Date().toISOString().split('T')[0]
    };
    
    // Etiket bilgilerini gÃ¼ncelle
    if (label !== undefined) {
      if (label === null) {
        // Etiketi kaldÄ±r
        delete manhwalar[seriesIndex].label;
      } else {
        // Etiketi gÃ¼ncelle
        manhwalar[seriesIndex].label = label;
      }
    }
    
    // DosyayÄ± gÃ¼ncelle
    await fs.writeFile(dataPath, JSON.stringify(manhwalar, null, 2));
    
    res.json({ 
      message: 'Seri baÅŸarÄ±yla gÃ¼ncellendi',
      series: manhwalar[seriesIndex]
    });
  } catch (error) {
    console.error('Seri gÃ¼ncelleme hatasÄ±:', error);
    res.status(500).json({ error: 'Seri gÃ¼ncellenirken hata oluÅŸtu' });
  }
});

// BÃ¶lÃ¼m ekle
router.post('/add-chapter/:seriesId', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId } = req.params;
    const { chapterNumber, title, imageUrls } = req.body;
    const user = req.moderatorUser;
    
    // Yetki kontrolÃ¼
    if (!user.isAdmin && (!user.isModerator || !user.moderatorSeries.includes(seriesId))) {
      return res.status(403).json({ error: 'Bu seri iÃ§in yetkiniz yok' });
    }
    
    // Validasyon
    if (!chapterNumber || !imageUrls || !Array.isArray(imageUrls) || imageUrls.length === 0) {
      return res.status(400).json({ error: 'BÃ¶lÃ¼m numarasÄ± ve en az bir gÃ¶rsel URL gerekli' });
    }
    
    const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
    const data = await fs.readFile(dataPath, 'utf8');
    const manhwalar = JSON.parse(data);
    
    const seriesIndex = manhwalar.findIndex(series => series.seriesId === seriesId);
    if (seriesIndex === -1) {
      return res.status(404).json({ error: 'Seri bulunamadÄ±' });
    }
    
    const series = manhwalar[seriesIndex];
    
    // Chapters array'ini kontrol et/oluÅŸtur
    if (!series.chapters) {
      series.chapters = [];
    }
    
    // BÃ¶lÃ¼m Ã§akÄ±ÅŸma kontrolÃ¼
    const existingChapterIndex = series.chapters.findIndex(ch => ch.number === chapterNumber);
    
    const newChapter = {
      number: chapterNumber,
      title: title || `BÃ¶lÃ¼m ${chapterNumber}`,
      filename: `bÃ¶lÃ¼m${chapterNumber}.html`,
      imageCount: imageUrls.length,
      uploadDate: new Date().toISOString(),
      imageUrls: imageUrls
    };
    
    if (existingChapterIndex !== -1) {
      // Mevcut bÃ¶lÃ¼mÃ¼ gÃ¼ncelle
      series.chapters[existingChapterIndex] = newChapter;
    } else {
      // Yeni bÃ¶lÃ¼m ekle
      series.chapters.push(newChapter);
    }
    
    // BÃ¶lÃ¼mleri numaraya gÃ¶re sÄ±rala
    series.chapters.sort((a, b) => a.number - b.number);
    
    // Seri bilgilerini gÃ¼ncelle
    series.chapterCount = series.chapters.length;
    series.lastChapter = `BÃ¶lÃ¼m ${Math.max(...series.chapters.map(ch => ch.number))}`;
    series.lastUpdated = new Date().toISOString().split('T')[0];
    series.availableChapters = series.chapters.map(ch => ch.number);
    
    // chapterDetails array'ini gÃ¼ncelle  
    if (!series.chapterDetails) {
      series.chapterDetails = [];
    }
    
    // Folder name mapping
    const folderNameMap = {
      'blackcrow': 'blackcrow chapters',
      'sololeveling': 'solo leveling chapters', 
      'nanomachine': 'nanomachine chapters',
      'damnreincarnation': 'damn reincarnation chapters',
      'omniscientreader': 'omniscient reader chapters',
      'martialgodregressedtolevel2': 'martial god regressed to level 2 chapters'
    };
    
    const folderName = folderNameMap[seriesId] || `${seriesId} chapters`;
    
    // Yeni chapter detail ekle/gÃ¼ncelle
    const newChapterDetail = {
      number: chapterNumber,
      filename: `bÃ¶lÃ¼m${chapterNumber}.html`,
      url: `chapters/${folderName}/bÃ¶lÃ¼m${chapterNumber}.html`
    };
    
    const existingDetailIndex = series.chapterDetails.findIndex(detail => detail.number === chapterNumber);
    if (existingDetailIndex !== -1) {
      series.chapterDetails[existingDetailIndex] = newChapterDetail;
    } else {
      series.chapterDetails.push(newChapterDetail);
    }
    
    // Chapter details'i sÄ±rala
    series.chapterDetails.sort((a, b) => a.number - b.number);
    
    // Dosyaya kaydet
    await fs.writeFile(dataPath, JSON.stringify(manhwalar, null, 2));
    
    res.json({
      success: true,
      message: `BÃ¶lÃ¼m ${chapterNumber} baÅŸarÄ±yla ${existingChapterIndex !== -1 ? 'gÃ¼ncellendi' : 'eklendi'}`,
      chapter: newChapter,
      imageCount: imageUrls.length
    });
    
  } catch (error) {
    console.error('BÃ¶lÃ¼m ekleme hatasÄ±:', error);
    res.status(500).json({ error: 'BÃ¶lÃ¼m eklenemedi' });
  }
});

// BÃ¶lÃ¼m gÃ¼ncelle
router.put('/update-chapter/:seriesId/:chapterNumber', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId, chapterNumber } = req.params;
    const { newNumber, title, imageUrls } = req.body;
    const user = req.moderatorUser;
    
    // Yetki kontrolÃ¼
    if (!user.isAdmin && (!user.isModerator || !user.moderatorSeries.includes(seriesId))) {
      return res.status(403).json({ error: 'Bu seri iÃ§in yetkiniz yok' });
    }
    
    const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
    const data = await fs.readFile(dataPath, 'utf8');
    const manhwalar = JSON.parse(data);
    
    const seriesIndex = manhwalar.findIndex(series => series.seriesId === seriesId);
    if (seriesIndex === -1) {
      return res.status(404).json({ error: 'Seri bulunamadÄ±' });
    }
    
    const series = manhwalar[seriesIndex];
    if (!series.chapters) {
      return res.status(404).json({ error: 'BÃ¶lÃ¼m bulunamadÄ±' });
    }
    
    const chapterIndex = series.chapters.findIndex(ch => ch.number === parseInt(chapterNumber));
    if (chapterIndex === -1) {
      return res.status(404).json({ error: 'BÃ¶lÃ¼m bulunamadÄ±' });
    }
    
    // EÄŸer bÃ¶lÃ¼m numarasÄ± deÄŸiÅŸiyorsa Ã§akÄ±ÅŸma kontrolÃ¼
    if (newNumber !== parseInt(chapterNumber)) {
      const conflictIndex = series.chapters.findIndex(ch => ch.number === newNumber);
      if (conflictIndex !== -1 && conflictIndex !== chapterIndex) {
        return res.status(400).json({ error: `BÃ¶lÃ¼m ${newNumber} zaten mevcut` });
      }
    }
    
    // BÃ¶lÃ¼mÃ¼ gÃ¼ncelle
    series.chapters[chapterIndex] = {
      ...series.chapters[chapterIndex],
      number: newNumber || parseInt(chapterNumber),
      title: title || series.chapters[chapterIndex].title,
      imageUrls: imageUrls || series.chapters[chapterIndex].imageUrls,
      imageCount: imageUrls ? imageUrls.length : series.chapters[chapterIndex].imageCount,
      filename: `bÃ¶lÃ¼m${newNumber || chapterNumber}.html`
    };
    
    // BÃ¶lÃ¼mleri numaraya gÃ¶re sÄ±rala
    series.chapters.sort((a, b) => a.number - b.number);
    
    // Seri bilgilerini gÃ¼ncelle
    series.chapterCount = series.chapters.length;
    series.lastChapter = `BÃ¶lÃ¼m ${Math.max(...series.chapters.map(ch => ch.number))}`;
    series.lastUpdated = new Date().toISOString().split('T')[0];
    series.availableChapters = series.chapters.map(ch => ch.number);
    
    // Dosyaya kaydet
    await fs.writeFile(dataPath, JSON.stringify(manhwalar, null, 2));
    
    res.json({
      success: true,
      message: `BÃ¶lÃ¼m baÅŸarÄ±yla gÃ¼ncellendi`,
      chapter: series.chapters[chapterIndex]
    });
    
  } catch (error) {
    console.error('BÃ¶lÃ¼m gÃ¼ncelleme hatasÄ±:', error);
    res.status(500).json({ error: 'BÃ¶lÃ¼m gÃ¼ncellenemedi' });
  }
});

// BÃ¶lÃ¼m sil
router.delete('/delete-chapter/:seriesId/:chapterNumber', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId, chapterNumber } = req.params;
    const user = req.moderatorUser;
    
    // Yetki kontrolÃ¼
    if (!user.isAdmin && (!user.isModerator || !user.moderatorSeries.includes(seriesId))) {
      return res.status(403).json({ error: 'Bu seri iÃ§in yetkiniz yok' });
    }
    
    const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
    const data = await fs.readFile(dataPath, 'utf8');
    const manhwalar = JSON.parse(data);
    
    const seriesIndex = manhwalar.findIndex(series => series.seriesId === seriesId);
    if (seriesIndex === -1) {
      return res.status(404).json({ error: 'Seri bulunamadÄ±' });
    }
    
    const series = manhwalar[seriesIndex];
    if (!series.chapters) {
      return res.status(404).json({ error: 'BÃ¶lÃ¼m bulunamadÄ±' });
    }
    
    const chapterIndex = series.chapters.findIndex(ch => ch.number === parseInt(chapterNumber));
    if (chapterIndex === -1) {
      return res.status(404).json({ error: 'BÃ¶lÃ¼m bulunamadÄ±' });
    }
    
    // BÃ¶lÃ¼mÃ¼ sil
    series.chapters.splice(chapterIndex, 1);
    
    // chapterDetails array'inden de sil
    if (series.chapterDetails) {
      const detailIndex = series.chapterDetails.findIndex(ch => ch.number === parseInt(chapterNumber));
      if (detailIndex !== -1) {
        series.chapterDetails.splice(detailIndex, 1);
      }
    }
    
    // Fiziksel HTML dosyasÄ±nÄ± sil
    try {
      const folderNameMap = {
        'blackcrow': 'blackcrow chapters',
        'sololeveling': 'solo leveling chapters',
        'nanomachine': 'nanomachine chapters',
        'damnreincarnation': 'damn reincarnation chapters',
        'omniscientreader': 'omniscient reader chapters',
        'martialgodregressedtolevel2': 'martial god regressed to level 2 chapters'
      };
      
      const folderName = folderNameMap[seriesId] || `${seriesId} chapters`;
      const chapterFilePath = path.join(__dirname, '../../client/chapters', folderName, `bÃ¶lÃ¼m${chapterNumber}.html`);
      
      console.log(`ğŸ” Fiziksel dosya silmeye Ã§alÄ±ÅŸÄ±lÄ±yor: ${chapterFilePath}`);
      
      // Dosya varsa sil
      try {
        await fs.access(chapterFilePath);
        await fs.unlink(chapterFilePath);
        console.log(`âœ… Fiziksel dosya baÅŸarÄ±yla silindi: ${chapterFilePath}`);
      } catch (fileError) {
        console.log(`âš ï¸ Fiziksel dosya bulunamadÄ± veya zaten silinmiÅŸti: ${chapterFilePath}`);
        console.log(`ğŸ“ Dosya silme hatasÄ± detayÄ±: ${fileError.message}`);
      }
      
      // AyrÄ±ca varsa ilgili gÃ¶rsel klasÃ¶rÃ¼nÃ¼ de sil
      const imageDir = path.join(__dirname, '../../client/images/bÃ¶lÃ¼mler', folderName.replace(' chapters', ''), `bÃ¶lÃ¼m${chapterNumber}`);
      try {
        await fs.rmdir(imageDir, { recursive: true });
        console.log(`âœ… GÃ¶rsel klasÃ¶rÃ¼ silindi: ${imageDir}`);
      } catch (imageDirError) {
        console.log(`âš ï¸ GÃ¶rsel klasÃ¶rÃ¼ bulunamadÄ±: ${imageDir}`);
      }
      
    } catch (fileDeleteError) {
      console.error('âŒ Fiziksel dosya silme hatasÄ±:', fileDeleteError);
      // Hata olsa bile JSON'dan silmeyi tamamla
    }
    
    // Seri bilgilerini gÃ¼ncelle
    series.chapterCount = series.chapters.length;
    if (series.chapters.length > 0) {
      series.lastChapter = `BÃ¶lÃ¼m ${Math.max(...series.chapters.map(ch => ch.number))}`;
      series.availableChapters = series.chapters.map(ch => ch.number);
      
      // chapterDetails'i chapters array'i ile senkronize et
      if (series.chapterDetails && Array.isArray(series.chapterDetails)) {
        series.chapterDetails = series.chapterDetails.filter(detail => 
          series.chapters.some(ch => ch.number === detail.number)
        );
      }
    } else {
      series.lastChapter = '';
      series.availableChapters = [];
      // HiÃ§ bÃ¶lÃ¼m kalmadÄ±ysa chapterDetails'i de temizle
      series.chapterDetails = [];
    }
    series.lastUpdated = new Date().toISOString().split('T')[0];
    
    // Dosyaya kaydet
    await fs.writeFile(dataPath, JSON.stringify(manhwalar, null, 2));
    
    res.json({
      success: true,
      message: `BÃ¶lÃ¼m ${chapterNumber} baÅŸarÄ±yla silindi`
    });
    
  } catch (error) {
    console.error('BÃ¶lÃ¼m silme hatasÄ±:', error);
    res.status(500).json({ error: 'BÃ¶lÃ¼m silinemedi' });
  }
});

// BÃ¶lÃ¼m gÃ¼ncelleme endpoint'i
router.put('/update-chapter/:seriesId/:chapterNumber', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId, chapterNumber } = req.params;
    const { title, imageUrls, newChapterNumber } = req.body;
    const user = req.moderatorUser;
    
    // Seri ID validasyonu
    if (!isValidSeriesId(seriesId)) {
      return res.status(400).json({ 
        error: 'GeÃ§ersiz seri ID', 
        validIds: require('../utils/seriesHelper').getAllSeriesIds() 
      });
    }
    
    // Yetki kontrolÃ¼
    if (!user.isAdmin && (!user.isModerator || !user.moderatorSeries.includes(seriesId))) {
      return res.status(403).json({ error: 'Bu seri iÃ§in yetkiniz yok' });
    }
    
    // BÃ¶lÃ¼m verisi validasyonu
    if (newChapterNumber) {
      const chapterData = { seriesId, chapterNumber: newChapterNumber, imageUrls };
      const validation = validateChapterData(chapterData);
      
      if (!validation.isValid) {
        return res.status(400).json({ 
          error: 'Validasyon hatasÄ±', 
          details: validation.errors 
        });
      }
    }
    
    const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
    const data = await fs.readFile(dataPath, 'utf8');
    const manhwalar = JSON.parse(data);
    
    const seriesIndex = manhwalar.findIndex(series => series.seriesId === seriesId);
    if (seriesIndex === -1) {
      return res.status(404).json({ error: 'Seri bulunamadÄ±' });
    }
    
    const series = manhwalar[seriesIndex];
    if (!series.chapters) {
      return res.status(404).json({ error: 'BÃ¶lÃ¼m bulunamadÄ±' });
    }
    
    const chapterIndex = series.chapters.findIndex(ch => ch.number === parseInt(chapterNumber));
    if (chapterIndex === -1) {
      return res.status(404).json({ error: 'BÃ¶lÃ¼m bulunamadÄ±' });
    }
    
    // BÃ¶lÃ¼mÃ¼ gÃ¼ncelle
    const chapter = series.chapters[chapterIndex];
    if (title) chapter.title = title;
    if (imageUrls && Array.isArray(imageUrls)) {
      chapter.imageUrls = imageUrls;
      chapter.imageCount = imageUrls.length;
    }
    if (newChapterNumber && newChapterNumber !== parseInt(chapterNumber)) {
      chapter.number = parseInt(newChapterNumber);
    }
    
    // Seri bilgilerini gÃ¼ncelle
    series.lastUpdated = new Date().toISOString().split('T')[0];
    
    // Dosyaya kaydet
    await fs.writeFile(dataPath, JSON.stringify(manhwalar, null, 2));
    
    res.json({
      success: true,
      message: 'BÃ¶lÃ¼m baÅŸarÄ±yla gÃ¼ncellendi',
      chapter: chapter
    });
    
  } catch (error) {
    console.error('BÃ¶lÃ¼m gÃ¼ncelleme hatasÄ±:', error);
    res.status(500).json({ error: 'BÃ¶lÃ¼m gÃ¼ncellenemedi' });
  }
});

// BÃ¶lÃ¼m ekleme endpoint'i
router.post('/add-chapter/:seriesId', verifyToken, verifyModerator, async (req, res) => {
  try {
    const { seriesId } = req.params;
    const { chapterNumber, title, imageUrls } = req.body;
    const user = req.moderatorUser;
    
    // Seri ID validasyonu
    if (!isValidSeriesId(seriesId)) {
      return res.status(400).json({ 
        error: 'GeÃ§ersiz seri ID', 
        validIds: require('../utils/seriesHelper').getAllSeriesIds() 
      });
    }
    
    // Yetki kontrolÃ¼
    if (!user.isAdmin && (!user.isModerator || !user.moderatorSeries.includes(seriesId))) {
      return res.status(403).json({ error: 'Bu seri iÃ§in yetkiniz yok' });
    }
    
    // BÃ¶lÃ¼m verisi validasyonu
    const chapterData = { seriesId, chapterNumber, imageUrls };
    const validation = validateChapterData(chapterData);
    
    if (!validation.isValid) {
      return res.status(400).json({ 
        error: 'Validasyon hatasÄ±', 
        details: validation.errors 
      });
    }
    
    const dataPath = path.join(__dirname, '../../client/data/manhwalar.json');
    const data = await fs.readFile(dataPath, 'utf8');
    const manhwalar = JSON.parse(data);
    
    const seriesIndex = manhwalar.findIndex(series => series.seriesId === seriesId);
    if (seriesIndex === -1) {
      return res.status(404).json({ error: 'Seri bulunamadÄ±' });
    }
    
    const series = manhwalar[seriesIndex];
    if (!series.chapters) {
      series.chapters = [];
    }
    
    // AynÄ± numaralÄ± bÃ¶lÃ¼m var mÄ± kontrol et
    const existingChapter = series.chapters.find(ch => ch.number === parseInt(chapterNumber));
    if (existingChapter) {
      return res.status(409).json({ error: 'Bu numaralÄ± bÃ¶lÃ¼m zaten mevcut' });
    }
    
    // Yeni bÃ¶lÃ¼mÃ¼ oluÅŸtur
    const newChapter = {
      number: parseInt(chapterNumber),
      title: title || `BÃ¶lÃ¼m ${chapterNumber}`,
      filename: `bÃ¶lÃ¼m${chapterNumber}.html`,
      imageCount: imageUrls.length,
      uploadDate: new Date().toISOString(),
      imageUrls: imageUrls
    };
    
    // BÃ¶lÃ¼mÃ¼ ekle ve sÄ±rala
    series.chapters.push(newChapter);
    series.chapters.sort((a, b) => a.number - b.number);
    
    // Seri bilgilerini gÃ¼ncelle
    series.chapterCount = series.chapters.length;
    series.lastChapter = `BÃ¶lÃ¼m ${Math.max(...series.chapters.map(ch => ch.number))}`;
    series.availableChapters = series.chapters.map(ch => ch.number);
    series.lastUpdated = new Date().toISOString().split('T')[0];
    
    // chapterDetails array'ini gÃ¼ncelle
    if (!series.chapterDetails) {
      series.chapterDetails = [];
    }
    
    // Folder name mapping
    const folderNameMap = {
      'blackcrow': 'blackcrow chapters',
      'sololeveling': 'solo leveling chapters',
      'nanomachine': 'nanomachine chapters',
      'damnreincarnation': 'damn reincarnation chapters',
      'omniscientreader': 'omniscient reader chapters',
      'martialgodregressedtolevel2': 'martial god regressed to level 2 chapters'
    };
    
    const folderName = folderNameMap[seriesId] || `${seriesId} chapters`;
    
    // Yeni chapter detail ekle
    const newChapterDetail = {
      number: parseInt(chapterNumber),
      filename: `bÃ¶lÃ¼m${chapterNumber}.html`,
      url: `chapters/${folderName}/bÃ¶lÃ¼m${chapterNumber}.html`
    };
    
    // Var olan chapter detail'i deÄŸiÅŸtir ya da ekle
    const existingDetailIndex = series.chapterDetails.findIndex(detail => detail.number === parseInt(chapterNumber));
    if (existingDetailIndex !== -1) {
      series.chapterDetails[existingDetailIndex] = newChapterDetail;
    } else {
      series.chapterDetails.push(newChapterDetail);
    }
    
    // Chapter details'i sÄ±rala
    series.chapterDetails.sort((a, b) => a.number - b.number);
    
    // Dosyaya kaydet
    await fs.writeFile(dataPath, JSON.stringify(manhwalar, null, 2));
    
    res.json({
      success: true,
      message: 'BÃ¶lÃ¼m baÅŸarÄ±yla eklendi',
      chapter: newChapter
    });
    
  } catch (error) {
    console.error('BÃ¶lÃ¼m ekleme hatasÄ±:', error);
    res.status(500).json({ error: 'BÃ¶lÃ¼m eklenemedi' });
  }
});

module.exports = router;
